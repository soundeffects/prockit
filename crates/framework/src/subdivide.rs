use crate::placement::Placement;
use bevy::prelude::*;

/// A collection of child placements offered by a parent node.
///
/// `Subdivide` is **space-agnostic**: each [`Placement`] can contain data for multiple spaces,
/// allowing nodes that exist in multiple spaces to offer placements with all relevant data.
///
/// # Example
/// ```
/// use prockit_framework::{Subdivide, Placement, SpacePlacement, RealSpace, RealSpacePlacement, RealSpaceRegion};
/// use bevy::prelude::*;
///
/// let subdivide = Subdivide::new()
///     .with(Placement::new()
///         .with_space::<RealSpace>(SpacePlacement {
///             placement_type: RealSpacePlacement::NodeSubdivide,
///             region: RealSpaceRegion::default(),
///             transform: Transform::from_translation(Vec3::X),
///             detail_scale: 0.5,
///         }))
///     .with(Placement::new()
///         .with_space::<RealSpace>(SpacePlacement {
///             placement_type: RealSpacePlacement::NodeSubdivide,
///             region: RealSpaceRegion::default(),
///             transform: Transform::from_translation(Vec3::NEG_X),
///             detail_scale: 0.5,
///         }));
/// ```
pub struct Subdivide {
    placements: Vec<Placement>,
}

impl Subdivide {
    /// Create an empty `Subdivide` with no placements.
    pub fn new() -> Self {
        Self {
            placements: Vec::new(),
        }
    }

    /// Add a placement to this `Subdivide`. Returns `&mut Self` for chaining.
    ///
    /// # Example
    /// ```
    /// # use prockit_framework::{Subdivide, Placement, SpacePlacement, RealSpace, RealSpacePlacement, RealSpaceRegion};
    /// # use bevy::prelude::*;
    /// let mut subdivide = Subdivide::new();
    /// subdivide.add(Placement::new()
    ///     .with_space::<RealSpace>(SpacePlacement {
    ///         placement_type: RealSpacePlacement::VolumeSubdivide,
    ///         region: RealSpaceRegion { min: Vec3::ZERO, max: Vec3::ONE },
    ///         transform: Transform::IDENTITY,
    ///         detail_scale: 0.5,
    ///     }));
    /// ```
    pub fn add(&mut self, placement: Placement) -> &mut Self {
        self.placements.push(placement);
        self
    }

    /// Add a placement to this `Subdivide`. Returns `Self` for builder pattern.
    ///
    /// # Example
    /// ```
    /// # use prockit_framework::{Subdivide, Placement, SpacePlacement, RealSpace, RealSpacePlacement, RealSpaceRegion};
    /// # use bevy::prelude::*;
    /// let subdivide = Subdivide::new()
    ///     .with(Placement::new()
    ///         .with_space::<RealSpace>(SpacePlacement {
    ///             placement_type: RealSpacePlacement::VolumeSubdivide,
    ///             region: RealSpaceRegion { min: Vec3::ZERO, max: Vec3::ONE },
    ///             transform: Transform::IDENTITY,
    ///             detail_scale: 0.5,
    ///         }));
    /// ```
    pub fn with(mut self, placement: Placement) -> Self {
        self.placements.push(placement);
        self
    }

    /// Get the placements in this `Subdivide`.
    pub fn placements(&self) -> &[Placement] {
        &self.placements
    }

    /// Consume this `Subdivide` and return the placements.
    pub fn into_placements(self) -> Vec<Placement> {
        self.placements
    }

    /// Returns `true` if this `Subdivide` has no placements.
    pub fn is_empty(&self) -> bool {
        self.placements.is_empty()
    }

    /// Returns the number of placements.
    pub fn len(&self) -> usize {
        self.placements.len()
    }
}

impl Default for Subdivide {
    fn default() -> Self {
        Self::new()
    }
}

/// Marker component indicating that an entity should be subdivided and its subdivisions
/// generated by the framework, which will assign an asynchronous generation task
/// at the next opportunity.
#[derive(Component)]
pub struct PendingGenerate;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{RealSpace, RealSpacePlacement, RealSpaceRegion, SpacePlacement};

    #[test]
    fn test_subdivide_new_is_empty() {
        let subdivide = Subdivide::new();
        assert!(subdivide.is_empty());
        assert_eq!(subdivide.len(), 0);
    }

    #[test]
    fn test_subdivide_add() {
        let mut subdivide = Subdivide::new();
        subdivide.add(Placement::new().with_space::<RealSpace>(SpacePlacement {
            placement_type: RealSpacePlacement::NodeSubdivide,
            region: RealSpaceRegion::default(),
            transform: Transform::IDENTITY,
            detail_scale: 1.0,
        }));

        assert!(!subdivide.is_empty());
        assert_eq!(subdivide.len(), 1);
    }

    #[test]
    fn test_subdivide_with_chaining() {
        let subdivide = Subdivide::new()
            .with(Placement::new().with_space::<RealSpace>(SpacePlacement {
                placement_type: RealSpacePlacement::NodeSubdivide,
                region: RealSpaceRegion::default(),
                transform: Transform::from_translation(Vec3::X),
                detail_scale: 0.5,
            }))
            .with(Placement::new().with_space::<RealSpace>(SpacePlacement {
                placement_type: RealSpacePlacement::NodeSubdivide,
                region: RealSpaceRegion::default(),
                transform: Transform::from_translation(Vec3::NEG_X),
                detail_scale: 0.5,
            }));

        assert_eq!(subdivide.len(), 2);
    }

    #[test]
    fn test_subdivide_placements_access() {
        let subdivide = Subdivide::new()
            .with(Placement::new().with_space::<RealSpace>(SpacePlacement {
                placement_type: RealSpacePlacement::VolumeSubdivide,
                region: RealSpaceRegion::default(),
                transform: Transform::IDENTITY,
                detail_scale: 1.0,
            }));

        let placements = subdivide.placements();
        assert_eq!(placements.len(), 1);
        assert!(placements[0].has_space::<RealSpace>());
    }

    #[test]
    fn test_subdivide_into_placements() {
        let subdivide = Subdivide::new()
            .with(Placement::new())
            .with(Placement::new());

        let placements = subdivide.into_placements();
        assert_eq!(placements.len(), 2);
    }
}
