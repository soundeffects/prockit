use super::{Pod, ProceduralNode, Provider, Space};
use bevy::{
    prelude::*,
    tasks::{AsyncComputeTaskPool, Task, block_on},
};

pub struct Subdivision {
    insertions: Vec<Box<dyn FnOnce(EntityCommands) + Send + Sync>>,
    generation:
        Box<dyn FnOnce(&Provider) -> Box<dyn FnOnce(EntityCommands) + Send + Sync> + Send + Sync>,
}

impl Subdivision {
    pub(crate) fn new<T: ProceduralNode>() -> Self {
        Subdivision {
            generation: Box::new(|provider| {
                let pod = Pod::<T>::generate(provider);
                let mut new_provider = provider.clone();
                T::provides(new_provider.provides(&pod));
                let closure = move |mut commands: EntityCommands| {
                    commands.insert((pod, new_provider));
                };
                Box::new(closure)
            }),
            insertions: Vec::new(),
        }
    }

    pub fn transform<S: Space>(&mut self, transform: S::LocalTransform) -> &mut Self {
        let closure = move |mut commands: EntityCommands| {
            commands.insert(transform);
        };
        self.insertions.push(Box::new(closure));
        self
    }

    fn generate(mut self, provider: &Provider) -> EntityInsertions {
        let node_insertion = (self.generation)(provider);
        self.insertions.push(node_insertion);
        EntityInsertions {
            insertions: self.insertions,
        }
    }
}

struct EntityInsertions {
    insertions: Vec<Box<dyn FnOnce(EntityCommands) + Send + Sync>>,
}

impl EntityInsertions {
    fn insert(self, mut commands: EntityCommands) {
        for insertion in self.insertions {
            insertion(commands.reborrow());
        }
    }
}

pub struct Subdivide {
    subdivisions: Vec<Subdivision>,
}

impl Subdivide {
    pub fn add<'a, T: ProceduralNode>(&'a mut self) -> &'a mut Subdivision {
        self.subdivisions.push(Subdivision::new::<T>());
        self.subdivisions.last_mut().unwrap()
    }

    fn generate(self, provider: Provider) -> MultiEntityInsertions {
        MultiEntityInsertions {
            entities: self
                .subdivisions
                .into_iter()
                .map(|subdivision| subdivision.generate(&provider))
                .collect(),
        }
    }
}

struct MultiEntityInsertions {
    entities: Vec<EntityInsertions>,
}

impl MultiEntityInsertions {
    fn insert(self, mut commands: EntityCommands) {
        commands.with_children(|parent| {
            for entity_insertions in self.entities {
                entity_insertions.insert(parent.spawn_empty());
            }
        });
    }
}

/// Marker component indicating that an entity should be subdivided and its subdivisions
/// generated by the [`FrameworkPlugin`], which will assign an asynchronous generation task
/// at the next opportunity.
#[derive(Component)]
pub struct PendingGenerate;

/// Marker component for leaf nodes that cannot subdivide further. Applied to nodes whose
/// [`ProceduralNode::subdivide`] returns `None`, indicating they are at maximum detail level.
#[derive(Component)]
pub(crate) struct EmptyNode;

/// This component is attached to entities while their children are being generated
/// in the background using Bevy's async compute task pool. Once the task completes,
/// the generated children are spawned and this component is removed.
#[derive(Component)]
pub(crate) struct GenerateTask {
    task: Task<MultiEntityInsertions>,
}

impl GenerateTask {
    /// System that creates async generation tasks for entities with [`PendingGenerate`]. It
    /// will handle transform and [`Provider`] propogation. For nodes that return `None` from
    /// `subdivide()`, an [`EmptyNode`] marker is added instead.
    pub(crate) fn create_tasks<T: ProceduralNode>(
        mut commands: Commands,
        pending_tasks: Query<(Entity, &Pod<T>, &Provider), With<PendingGenerate>>,
    ) {
        let task_pool = AsyncComputeTaskPool::get();

        for (entity, pod, provider) in pending_tasks {
            let mut entity_commands = commands.entity(entity);
            entity_commands.remove::<PendingGenerate>();
            if let Some(subdivisions) = pod.subdivide() {
                let provider = provider.clone();
                entity_commands.insert(Self {
                    task: task_pool.spawn(async move { subdivisions.generate(provider) }),
                });
            } else {
                entity_commands.insert(EmptyNode);
            }
        }
    }

    /// System that polls pending generation tasks and spawns completed children.
    pub(crate) fn poll_tasks(mut commands: Commands, tasks: Query<(Entity, &mut GenerateTask)>) {
        for (entity, mut task) in tasks {
            if task.task.is_finished() {
                let mut parent = commands.entity(entity);
                parent.remove::<GenerateTask>();
                block_on(&mut task.task).insert(parent);
            }
        }
    }
}
